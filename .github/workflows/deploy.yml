name: CI/CD pipeline

on:
  push:
    branches:
      - dev
      - main
      - staging
  pull_request:
    branches:
      - main
      - staging

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint-build-test:
    name: Lint, Build and Test
    env:
      SKIP_CI: ${{ contains(github.event.head_commit.message, '#skip-ci') || contains(github.event.pull_request.title, '#skip-ci') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        if: env.SKIP_CI != 'true'
        uses: actions/checkout@v6

      - uses: actions/setup-node@v6
        if: env.SKIP_CI != 'true'
        with:
          node-version: latest

      - name: Install node_modules, lint and build
        if: env.SKIP_CI != 'true'
        run: |
          npm ci
          npm run lint
          npm run build

      - name: Run tests and generate coverage report
        if: env.SKIP_CI != 'true'
        run: |
          export AUTH_SECRET=$(uuidgen)
          npm run coverage:unit
          npm run e2e:headless
          npm run coverage:report

      - name: Upload results to Codecov
        if: env.SKIP_CI != 'true'
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  gen-tags:
    name: Generate Docker tags
    runs-on: ubuntu-latest
    needs: lint-build-test
    outputs:
      tags: ${{ steps.set_tags.outputs.tags }}

    if: >
      github.event_name == 'push'
      && github.ref_name != 'dev'

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - id: set_tags
        run: |
          git fetch --tags || true

          TAG=$(cat package.json | jq -r '.version')
          echo "Found package.json version: $TAG"

          if ! git tag --list | grep -qx "v$TAG"; then
            # every single release should end up in staging
            # publish all semvers "X.Y.Z" + "X.Y" + "X"
            TAGS=($TAG ${TAG%.*} ${TAG%%.*} staging)

            # add "latest" if we're deploying to PROD
            if [[ " ${{ github.event.head_commit.message }} " == *" #deploy "* ]]; then
              echo "‚ùó bumping tag latest"
              TAGS+=(latest)
            fi

            # prepend the repo and collect image tags
            IMAGE_TAGS=()
            for tag in ${TAGS[@]}; do
              IMAGE_TAGS+=(tomjtoth/saldo:$tag)
            done

            # write space-delimited tags as the step output
            {
              echo 'tags<<EOF'
              tr ' ' '\n' <<< "${IMAGE_TAGS[@]}"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
          else
            echo "tags=" >> $GITHUB_OUTPUT
          fi

  gen-image:
    name: Generate Docker image
    runs-on: ubuntu-latest
    needs: gen-tags
    if: ${{ needs.gen-tags.outputs.tags }} != ''

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/arm64
          load: true # load image into local docker so we can inspect
          push: false
          tags: |
            ${{ needs.gen-tags.outputs.tags }}
          build-args: |
            GIT_HASH=${{ github.sha }}
          cache-from: type=gha,scope=shared
          cache-to: type=gha,mode=max,scope=shared

      - name: Check image size
        run: |
          TAGS=(${{ needs.gen-tags.outputs.tags }})
          SIZE_BYTES=$(docker image inspect ${TAGS[0]} --format='{{.Size}}')
          SIZE_MB=$((SIZE_BYTES / 1024 / 1024))
          MAX_SIZE_MB=300

          if [ "$SIZE_MB" -gt "$MAX_SIZE_MB" ]; then
            echo "üìà Docker image exceeds ${MAX_SIZE_MB} MB (got ${SIZE_MB} MB)"
            exit 1
          else
            echo "Image size: ${SIZE_MB} MB"
          fi

      - name: Push image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: |
            ${{ needs.gen-tags.outputs.tags }}
          build-args: |
            GIT_HASH=${{ github.sha }}
          cache-from: type=gha,scope=shared
          cache-to: type=gha,mode=max,scope=shared

  gitops:
    name: Update images in vps/apps/saldo/kustomization.yml
    runs-on: ubuntu-latest
    if: ${{ contains(needs.gen-tags.outputs.tags, ':latest') }}
    needs:
      - gen-tags
      - gen-image
    steps:
      - name: GitOps in repo `vps`
        run: |
          # Clone the vps repo
          git clone https://x-access-token:${{ secrets.VPS_REPO_PAT }}@github.com/tomjtoth/vps.git /tmp/vps
          cd /tmp/vps

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          KUSTOMIZATION_FILE="apps/saldo/kustomization.yml"
          TAGS=(${{ needs.gen-tags.outputs.tags }})


          # staging always changes
          yq e '(.images[] | select(.name=="IMAGES/STAGING")).newName = "'"${TAGS[0]}"'"' -i "$KUSTOMIZATION_FILE"

          # prod only if "#deploy" is in HEAD commit message
          if [[ " $TAGS " == *" :latest "* ]]; then
            yq e '(.images[] | select(.name=="IMAGES/PROD")).newName = "'"${TAGS[0]}"'"' -i "$KUSTOMIZATION_FILE"
          fi


          # Commit and push if there are changes
          if git diff --quiet; then
            echo "No changes to commit"
          else
            msg="Updated image to ${TAGS[0]}"
            git add "$KUSTOMIZATION_FILE"
            git commit -m "$msg"
            git push origin main
            echo "‚úÖ $msg"
          fi

  rel-tag:
    name: Release new tag to repo
    needs:
      - gen-tags
      - gitops
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Create tag
        run: |
          TAGS=(${{ needs.gen-tags.outputs.tags }})
          TAG=v${TAGS[0]#*:}

          # create annotated tag and push it back to the repo
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"
