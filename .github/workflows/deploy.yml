name: CI/CD pipeline

on:
  push:
    branches:
      - dev
      - main
      - staging
  pull_request:
    branches:
      - main
      - staging

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  lint-build-test:
    name: Lint, Build and Test
    env:
      SKIP_CI: ${{ contains(github.event.head_commit.message, '#skip-ci') || contains(github.event.pull_request.title, '#skip-ci') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        if: env.SKIP_CI != 'true'
        uses: actions/checkout@v6

      - uses: actions/setup-node@v6
        if: env.SKIP_CI != 'true'
        with:
          node-version: latest

      - name: Install node_modules, lint and build
        if: env.SKIP_CI != 'true'
        run: |
          npm ci
          npm run lint
          npm run build

      - name: Run tests and generate coverage report
        if: env.SKIP_CI != 'true'
        run: |
          export AUTH_SECRET=$(uuidgen)
          npm run coverage:unit
          npm run e2e:headless
          npm run coverage:report

      - name: Upload results to Codecov
        if: env.SKIP_CI != 'true'
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  pre-deploy:
    name: Generate Docker tags
    runs-on: ubuntu-latest
    needs: lint-build-test
    outputs:
      tags: ${{ steps.set_tags.outputs.tags }}

    if: >
      github.event_name == 'push'

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - id: set_tags
        run: |
          git fetch --tags || true

          TAG=$(cat package.json | jq -r '.version')
          echo "Found package.json version: $TAG"

          if ! git tag --list | grep -qx "v$TAG"; then
            # every single release should end up in staging
            # publish all semvers "X.Y.Z" + "X.Y" + "X"
            TAGS=($TAG ${TAG%.*} ${TAG%%.*} staging)

            # create annotated tag and push it back to the repo
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git tag -a "v$TAG" -m "Release $TAG"
            git push origin "v$TAG"

            # add "latest" if we're deploying to PROD
            if [[ " ${{ github.event.head_commit.message }} " == " #deploy " ]]; then
              TAGS+=(latest)
            fi

            # prepend the repo and collect image tags
            IMAGE_TAGS=()
            for tag in ${TAGS[@]}; do
              IMAGE_TAGS+=(tomjtoth/saldo:$tag)
            done

            # write space-delimited tags as the step output
            echo "tags=${IMAGE_TAGS[*]}" >> $GITHUB_OUTPUT
          else
            echo "tags=" >> $GITHUB_OUTPUT
          fi

  deploy:
    name: Generate Docker image
    runs-on: ubuntu-latest
    needs: pre-deploy
    if: ${{ needs.pre-deploy.outputs.tags }} != ''

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - run: |
          TAGS="${{ needs.pre-deploy.outputs.tags }}"
          echo "TAGS=\"$(tr " " "\n" <<< "$TAGS")\"" >> $GITHUB_ENV

      - name: Build image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/arm64
          load: true # load image into local docker so we can inspect
          push: false
          tags: |
            ${{ env.TAGS }}
          build-args: |
            GIT_HASH=${{ github.sha }}
          cache-from: type=gha,scope=shared
          cache-to: type=gha,mode=max,scope=shared

      - name: Check image size
        run: |
          TAGS=(${{ env.TAGS }})
          SIZE_BYTES=$(docker image inspect "${TAGS[0]}" --format='{{.Size}}')
          SIZE_MB=$((SIZE_BYTES / 1024 / 1024))
          MAX_SIZE_MB=300

          if [ "$SIZE_MB" -gt "$MAX_SIZE_MB" ]; then
            echo "ðŸ“ˆ Docker image exceeds ${MAX_SIZE_MB} MB (got ${SIZE_MB} MB)"
            exit 1
          else
            echo "Image size: ${SIZE_MB} MB"
          fi

      - name: Push image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: |
            ${{ env.TAGS }}
          build-args: |
            GIT_HASH=${{ github.sha }}
          cache-from: type=gha,scope=shared
          cache-to: type=gha,mode=max,scope=shared

  post-deploy:
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: GitOps in repo `vps`
        run: |
          # Clone the vps repo
          git clone https://x-access-token:${{ secrets.VPS_REPO_PAT }}@github.com/tomjtoth/vps.git /tmp/vps
          cd /tmp/vps

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Update the image tag in kustomization.yml
          KUSTOMIZATION_FILE="apps/saldo/kustomization.yml"

          TAGS=(${{ needs.pre-deploy.outputs.tags }})
          # Update newTag in kustomization.yml (adjust the image name as needed)
          # sed -i "s/newName:.*/newName: ${TAGS[0]}/" "$KUSTOMIZATION_FILE"
          yq e '(.images[] | select(.name=="IMAGES/PROD")).newName = "'"${TAGS[0]}"'"' -i "$KUSTOMIZATION_FILE"

          # Commit and push if there are changes
          if git diff --quiet; then
            echo "No changes to commit"
          else
            msg="Updated image to ${TAGS[0]}"
            git add "$KUSTOMIZATION_FILE"
            git commit -m "$msg"
            git push origin main
            echo "âœ… $msg"
          fi
